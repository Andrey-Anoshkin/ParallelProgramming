\documentclass[bachelor, och, referat]{SCWorks}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tempora}
\usepackage{minted}
\usepackage{import}
\graphicspath{ {./images/} }
%\definecolor{codebg}{rgb}{0.9,0.9,0.9} %описание собственного цвета (почти
%белый) \setminted{         % установка параметров по умолчанию для команд
%бибилиотеки minted bgcolor=codebg, % установка цвета фона программного кода
%linenos=true,   % включение номеров строк в листингах numbersep=5pt,  %
%промежуток между номерами строк и началом строк листинга breaklines}     %
%автоматические переносы строк (когда строки не умещаются)

\usemintedstyle{bw} % включение черно-белого стиля программного кода
	
\usepackage[hidelinks]{hyperref}

\setminted{
	style=bw,
	framesep=2mm, 
	baselinestretch=1.2, 
	fontsize=\footnotesize, 
	linenos,
	breaklines=true
}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Численное интегрирование, формула Симпсона, вычисление определенных и кратных интегралов}

% Курс
\course{3}

% Группа
\group{311}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}

% Для студентки. Для работы студента следующая команда не нужна.
\studenttitle{Студента}

% Фамилия, имя, отчество в родительном падеже
\author{Аношкина Андрея Алексеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\satitle{Старший преподаватель} %должность, степень, звание
\saname{М.\,С.\,Портенко}

% Руководитель практики от организации (только для практики, для остальных типов
% работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных типов работ не используется)
\term{6}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2016} \practFinish{14.07.2016}

% Год выполнения отчета
\date{2024}

\maketitle

\tableofcontents

% 1) 1
%///////////////////////////////////////////////////////////////////////////////
\section{Work 10}

\subsection*{Задание}

Аналогично работе с OMP выполните следующее задание через MPI.

Реализуйте параллельные алгоритмы, использующие метод прямоугольников и формулу
Симпсона для подсчета интегралов. Точные значения интегралов указаны для
проверки численных вычислений. В случае, если в верхнем пределе интегрирования
указан знак бесконечности, то в расчете необходимо заменить его на $10^6$. Сравните
время численного интегрирования для последовательной и параллельной реализации.
Какое ускорение выполнения программы предоставляет переход к многопоточной
версии?

Вариант задания 2:
\[\int_{0}^{\infty} \frac{\,dx}{1 + x ^ 2} = \frac{\pi}{2}  \]

\subsection*{Метод прямоугольников, формула Симпсона}

Метод прямоугольников геометрически заключается в том, что интеграл
приближенно представляется в виде суммы площадей элементарных
прямоугольников.

Для случая деления отрезка интегрирования на равные части и
вычисления функции в центре отрезков:
\begin{equation}
    \begin{cases}
		J = \int_{a}^{b} f(x)\,dx \approx \sum_{i = 0}^{N - 1} (h \cdot f (x_i)) = h \cdot \sum_{i = 0}^{N - 1} f (x_i)\\
		x_i = a + i \cdot h + \frac{h}{2}
	\end{cases}
\end{equation}

где $N$ --- количество отрезков интегрирования, а $h = (b - a) / N$

Ступенчатая (stair"=case) аппроксимация гладких изогнутых поверхностей, возникает
в результате дискретизации модели прямоугольной сеткой. Для борьбы со
ступенчатой аппроксимацией может использоваться, например, квадратурная формула
Симпсона:

\begin{equation}
	\int_{a}^{b} f(x)\,dx \approx \frac{h}{3} [ \,f(a) + f(b) + 4 \sum_{k = 1}^{N} f(a + (2k - 1)h) + 2 \sum_{k = 1}^{N - 1} f(a + 2kh)] \,
\end{equation}

где $h = \frac{b - a}{2N}, N \gg 1$.

Формула Симпсона геометрически заключается в том, что через три
ординаты, отвечающие трем последовательным узлам сетки, проводится
парабола и затем складываются получившиеся при этом площади
элементарных криволинейных трапеций.

\subsection*{Реализация}

Код решения приведен ниже:

\begin{minted}{cpp}
//MPI_Simpliest_c_Bind.cpp
#include "mpi.h"
#include <iostream>
#include <time.h>
#define PI 3.1415926535897932384626433832795

using namespace std;

int NProc, ProcId;
MPI_Status st;

double f1(double x) {
	return 1.0 / (1 + x * x);
}

void integral_posl(const double a, const double b, const double h, double* res) {
	double sum = 0;
	int n = (int)((b - a) / h);

	for (int i = 0; i < n; ++i) {
		double x = a + i * h + h / 2;
		sum += f1(x) * h;
	}

	*res = sum;
	
}

void integral_paral(const double a, const double b, const double h, double* res) {
	MPI_Barrier(MPI_COMM_WORLD);
	double sum = 0;
	int n = (int)((b - a) / h);

	for (int i = ProcId; i < n; i += NProc) {
		double x = a + i * h + h / 2;
		sum += f1(x) * h;
	}

	if (ProcId != 0) 
		MPI_Send(&sum, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
	else {
		for (int i = 1; i < NProc; ++i) {
			double s;
			MPI_Recv(&s, 1, MPI_DOUBLE, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &st);
			sum += s;
		}

		*res = sum;
	}
}

void integral_Simpson(const double a, const double b, const double h, double* res) {
	MPI_Barrier(MPI_COMM_WORLD);
	double sum = f1(a) + f1(b);
	int n = (int)((b - a) / 2 / h);

	for (int i = ProcId + 1; i <= n; i += NProc) {
		double x = a + h * (2 * i - 1);
		sum += f1(x) * 4;
	}

	for (int i = ProcId + 1; i < n; i += NProc) {
		double x = a + 2 * i * h;
		sum += 2 * f1(x);
	}

	if (ProcId != 0)
		MPI_Send(&sum, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
	else {
		for (int i = 1; i < NProc; ++i) {
			double s;
			MPI_Recv(&s, 1, MPI_DOUBLE, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &st);
			sum += s;
		}

		*res = h / 3 * sum;
	}
}

double experiment(double* res, void f(const double a, const double b, const double h, double* res)) {
	double stime = 0, ftime = 0;
	double a = 0;
	double b = 1e+6;
	double h = 0.01;
	stime = clock();
	f(a, b, h, res);
	ftime = clock();

	return (ftime - stime) / CLOCKS_PER_SEC;
}

void calculate(void f(const double a, const double b, const double h, double* res)) {
	double avg_time = 0;
	double min_time = 0;
	double max_time = 0;
	double res = 0;
	int numbExp = 1;

	min_time = max_time = experiment(&res, f);
	avg_time = min_time / numbExp;
	for (int i = 0; i < numbExp - 1; ++i) {
		double time = experiment(&res, f);
		if (time > max_time)
			max_time = time;
		if (time < min_time)
			min_time = time;

		avg_time += time / numbExp;
	}

	if (ProcId == 0) {
		cout << "Execution time: " << avg_time << "; " << min_time << "; " << max_time << "\n";
		cout.precision(8);
		cout << "Integral value: " << res << "\n";
	}
}

int main() {

	bool calcPosl = true, calcParal = true, calcSimpson = true;
	
	MPI_Init(NULL, NULL);
	MPI_Comm_size(MPI_COMM_WORLD, &NProc);
	MPI_Comm_rank(MPI_COMM_WORLD, &ProcId);

	// Последовательное вычисление

	if (calcPosl && ProcId == 0) {
		cout << "Posl:\n";
		calculate(integral_posl);
		cout << "\n";
	}

	// Параллельное вычисление

	if (calcParal) {
		if (ProcId == 0)
			cout << "Paral:\n";
		calculate(integral_paral);
		if (ProcId == 0)
			cout << "\n";
	}

	// Параллельное вычисление по формуле Симпсона

	if (calcSimpson) {
		if (ProcId == 0)
			cout << "Simpson:\n";
		calculate(integral_Simpson);
		if (ProcId == 0)
			cout << "\n";
	}

	MPI_Finalize();

	return 0;
}
\end{minted}

\subsection*{Результаты работы}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{work-1.png}
	\caption{Work"=1 (OpenMP)}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{work-10.png}
	\caption{Work"=10 (OpenMPI)}
\end{figure}

Результаты работы приложения с $OpenMPI$ оказались хуже, чем работа 
реализации с использованием $OpenMP$ в связи со временем, необходимым для пересылки
сообщений между процессами. Однако в перспективе более сложных
вычислений $OpenMPI$ гарантирует лучшую эффективность.

\subsection*{Характеристики устройства}

Процессор: Intel(R) Core(TM) i5-10400F

Ядер: 6

Оперативная память: 16 Гб

\end{document}
