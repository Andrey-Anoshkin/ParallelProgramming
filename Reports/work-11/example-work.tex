\documentclass[bachelor, och, referat]{SCWorks}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tempora}
\usepackage{minted}
\usepackage{import}
\graphicspath{ {./images/} }
%\definecolor{codebg}{rgb}{0.9,0.9,0.9} %описание собственного цвета (почти
%белый) \setminted{         % установка параметров по умолчанию для команд
%бибилиотеки minted bgcolor=codebg, % установка цвета фона программного кода
%linenos=true,   % включение номеров строк в листингах numbersep=5pt,  %
%промежуток между номерами строк и началом строк листинга breaklines}     %
%автоматические переносы строк (когда строки не умещаются)

\usemintedstyle{bw} % включение черно-белого стиля программного кода
	

\usepackage[hidelinks]{hyperref}

\setminted{
	style=bw,
	framesep=2mm, 
	baselinestretch=1.2, 
	fontsize=\footnotesize, 
	linenos,
	breaklines=true
}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Численное интегрирование, формула Симпсона, вычисление определенных и кратных интегралов}

% Курс
\course{3}

% Группа
\group{311}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}

% Для студентки. Для работы студента следующая команда не нужна.
\studenttitle{Студента}

% Фамилия, имя, отчество в родительном падеже
\author{Аношкина Андрея Алексеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\satitle{Старший преподаватель} %должность, степень, звание
\saname{М.\,С.\,Портенко}

% Руководитель практики от организации (только для практики, для остальных типов
% работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных типов работ не используется)
\term{6}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
\practStart{01.07.2016} \practFinish{14.07.2016}

% Год выполнения отчета
\date{2024}

\maketitle

\tableofcontents

% 1) 1
%///////////////////////////////////////////////////////////////////////////////



\section{Work 11}

\subsection*{Задание}

Аналогично работе с OMP выполните следующее задание через MPI.

Модифицируйте разработанную ранее программу по методу прямоугольников  для
численного интегрирования тестовой функции:

\begin{equation}
	\int_{0}^{16}\int_{0}^{16} \frac{e^{\cos(\pi x)\sin(\pi y)} + 1}{(b_1 - a_1)(b_2 - a_2)}\,dx\,dy \approx 2.130997
\end{equation}
Предложите несколько способов распараллеливания базового алгоритма метода
прямоугольников для двумерной функции с использованием директивы 
\newline \#pragma omp parallel for.
Реализуйте предложенные способы на примере тестовой функции.
Сравните время численного интегрирования для последовательной и параллельных
реализаций и параллельных реализаций между собой.

\subsection*{Численное интегрирование по методу прямоугольников для
двумерной функции}

\begin{equation}
    \begin{cases}
		J = \int_{a_1}^{b_1} \int_{a_2}^{b_2} f(x, y)\,dx \,dy \approx \sum_{i = 0}^{N - 1} \sum_{j = 0}^{M - 1} (h_1 \cdot h_2 \cdot f (x_i, y_i))\\
		x_i = a_1 + i \cdot h_1 + \frac{h_1}{2}\\
		y_i = a_2 + i \cdot h_2 + \frac{h_2}{2}
	\end{cases}
\end{equation}

где $N$ --- количество отрезков интегрирования по оси $x$, $M$ --- количество
отрезков интегрирования по оси $y$, $h_1 = (b_1 - a_1) / N$ и $h_2 = (b_2 - a_2) / N$.

\subsection*{Реализация}

Фрагмент кода решения приведен ниже:

\begin{minted}{cpp}
#include <iostream>
#include "mpi.h"
#include <time.h>
#include <cmath>
#define PI 3.1415926535897932384626433832795

using namespace std;

int NProc, ProcId;
MPI_Status st;

double f1(const double x, const double y, const double a1, const double b1, const double a2, const double b2) {
	return (1 + exp(sin(PI * x) * cos(PI * y))) / (b1 - a1) / (b2 - a2);
}

void integral_posl(const double a1, const double b1, const double a2, const double b2, const double h1, const double h2, double* res) {
	double sum = 0;
	int n = (int)((b1 - a1) / h1);
	int m = (int)((b2 - a2) / h2);

	for (int i = 0; i < n; ++i) {
		double x = a1 + i * h1 + h1 / 2;
		for (int j = 0; j < m; ++j) {
			double y = a2 + j * h2 + h2 / 2;
			sum += f1(x, y, a1, b1, a2, b2) * h1 * h2;
		}
	}

	*res = sum;
}

void integral_paral_1(const double a1, const double b1, const double a2, const double b2, const double h1, const double h2, double* res) {
	double sum = 0;
	int n = (int)((b1 - a1) / h1);
	int m = (int)((b2 - a2) / h2);

	for (int i = ProcId; i < n; i += NProc) {
		double x = a1 + i * h1 + h1 / 2;
		for (int j = 0; j < m; ++j) {
			double y = a2 + j * h2 + h2 / 2;
			sum += f1(x, y, a1, b1, a2, b2) * h1 * h2;
		}
	}

	if (ProcId != 0)
		MPI_Send(&sum, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
	else {
		for (int i = 1; i < NProc; ++i) {
			double s;
			MPI_Recv(&s, 1, MPI_DOUBLE, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &st);
			sum += s;
		}
			
		*res = sum;
	}
}

void integral_paral_2(const double a1, const double b1, const double a2, const double b2, const double h1, const double h2, double* res) {
	double sum = 0;
	int n = (int)((b1 - a1) / h1);
	int m = (int)((b2 - a2) / h2);

	for (int i = ProcId / 2; i < n; i += NProc / 2) {
		double x = a1 + i * h1 + h1 / 2;
		for (int j = ProcId % 2; j < m; j += NProc / 2) {
			double y = a2 + j * h2 + h2 / 2;
			sum += f1(x, y, a1, b1, a2, b2) * h1 * h2;
		}
	}

	if (ProcId != 0)
		MPI_Send(&sum, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
	else {
		for (int i = 1; i < NProc; ++i) {
			double s;
			MPI_Recv(&s, 1, MPI_DOUBLE, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &st);
			sum += s;
		}

		*res = sum;
	}
}

double experiment(double* res, void f(const double a1, const double b1, const double a2, const double b2, const double h1, const double h2, double* res)) {
	double stime = 0, ftime = 0;
	double a1 = 0, b1 = 16;
	double a2 = 0, b2 = 16;
	double h1 = 0.005, h2 = 0.005;
	stime = clock();
	f(a1, b1, a2, b2, h1, h2, res);
	ftime = clock();

	return (ftime - stime) / CLOCKS_PER_SEC;
}

void calculate(void f(const double a1, const double b1, const double a2, const double b2, const double h1, const double h2, double* res)) {
	double avg_time = 0;
	double min_time = 0;
	double max_time = 0;
	double res = 0;
	int numbExp = 10;

	min_time = max_time = experiment(&res, f);
	avg_time = min_time / numbExp;
	for (int i = 0; i < numbExp - 1; ++i) {
		double time = experiment(&res, f);
		if (time > max_time)
			max_time = time;
		if (time < min_time)
			min_time = time;

		avg_time += time / numbExp;
	}

	if (ProcId == 0) {
		cout << "Execution time: " << avg_time << "; " << min_time << "; " << max_time << "\n";
		cout.precision(8);
		cout << "Integral value: " << res << "\n";
	}
}

int main() {

	bool calcPosl = true, calcParal_1 = true, calcParal_2 = true;

	MPI_Init(NULL, NULL);
	MPI_Comm_size(MPI_COMM_WORLD, &NProc);
	MPI_Comm_rank(MPI_COMM_WORLD, &ProcId);

	// Последовательное вычисление

	if (calcPosl && ProcId == 0) {
		cout << "Posl:\n";
		calculate(integral_posl);
		cout << "\n";
	}

	// Параллельное вычисление (1)

	if (calcParal_1) {
		if (ProcId == 0)
			cout << "Paral_1:\n";
		calculate(integral_paral_1);
		if (ProcId == 0)
			cout << "\n";
	}

	// Параллельное вычисление (2)

	if (calcParal_2) {
		if (ProcId == 0)
			cout << "Paral_2:\n";
		calculate(integral_paral_2);
		if (ProcId == 0)
			cout << "\n";
	}

	MPI_Finalize();

	return 0;
}
\end{minted}

\subsection*{Результаты работы}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{work-2.png}
	\caption{Work"=2 (OpenMP)}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{work-11.png}
	\caption{Work"=11 (OpenMPI)}
\end{figure}

Статическое распределение задач по потокам показало наилучший результат. Динамическое распределение задач проиграло по времени в связи с необходимостью обмениваться сообщениями между потоками и диспетчером, но в случае более тяжелых задач является более эффективным.

\subsection*{Характеристики устройства}

Процессор: Intel(R) Core(TM) i5-10400F

Ядер: 6

Оперативная память: 16 Гб

\end{document}
